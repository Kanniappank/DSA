
/**
 * Design Patterns can be classified into three main categories:
 */

/**
 /**
 * Design Patterns can be classified into three main categories:
 */

/**
 * 1. Creational Patterns
 * - Deal with object creation mechanisms
 * - Factory Method: Used when a class can't anticipate the type of objects it needs to create
 * - Abstract Factory: Creates families of related objects without specifying concrete classes
 * - Builder: Constructs complex objects step by step, allowing different representations
 * - Prototype: Creates new objects by cloning an existing object (prototype)
 * - Singleton: Ensures a class has only one instance with global access point
 */

/**
 * 2. Structural Patterns  
 * - Deal with object composition and relationships
 * - Adapter: Allows incompatible interfaces to work together by wrapping object in an adapter
 * - Bridge: Separates abstraction from implementation so both can vary independently
 * - Composite: Composes objects into tree structures to represent part-whole hierarchies
 * - Decorator: Adds new responsibilities to objects dynamically without altering their code
 * - Facade: Provides unified interface to a set of interfaces in a subsystem
 * - Flyweight: Reduces memory usage by sharing common parts of state between multiple objects
 * - Proxy: Provides a surrogate for another object to control access to it
 */

/**
 * 3. Behavioral Patterns
 * - Deal with communication between objects
 * - Chain of Responsibility: Passes requests along a chain of handlers
 * - Command: Encapsulates a request as an object to parameterize clients
 * - Interpreter: Defines a grammar for instructions in a language
 * - Iterator: Provides way to access elements of collection without exposing structure
 * - Mediator: Reduces coupling by having objects communicate via mediator
 * - Memento: Captures and restores an object's internal state
 * - Observer: Defines one-to-many dependency between objects
 * - State: Allows object to alter behavior when internal state changes
 * - Strategy: Defines family of algorithms and makes them interchangeable
 * - Template Method: Defines skeleton of algorithm, letting subclasses override steps
 * - Visitor: Separates algorithm from object structure on which it operates
 */